<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas to PNG</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <style>
        canvas {
            border: 1px solid black;
            margin: 20px;
        }
        button {
            padding: 10px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="row text-center">

        <div class="col-3 mt-5 text-end">
            <div class="colorButton" data-color="#000000" style="background-color: #000000; height: 40px; width: 40px; display: inline-block;"></div>
            <div class="colorButton" data-color="#FF0000" style="background-color: #FF0000; height: 40px; width: 40px; display: inline-block;"></div>
            <div class="colorButton" data-color="#1100ff" style="background-color: #1100ff; height: 40px; width: 40px; display: inline-block;"></div>
        </div>

        <div class="col-6">
            <canvas id="myCanvas" width="900" height="900" style="border:1px solid #000;"></canvas>
        </div>

        <div class="col-3 text-start mt-3">
            <button class="sizeButton" data-size="5">Vékony</button>
            <button class="sizeButton" data-size="20">Vastag</button>
            <button id="fillModeButton" style="background-color: yellow;">Kitöltés</button>

            <br>
            <button id="canvasClear" style="background-color: red;" onclick="canvasClear()">Törlés</button>
            <button id="saveButton" style="background-color: aqua;">Mentés</button>
        </div>
    </div>


    <script>
        let socket = new WebSocket('wss://multiplayergameprojectthingycouldntcomeu.onrender.com');
     socket.onopen = () =>
     {
         console.log('WebSocket connection established');
     };
     
     const canvas = document.getElementById('myCanvas');
     const ctx = canvas.getContext('2d');
     const colorButtons = document.querySelectorAll('.colorButton');
     const sizeButtons = document.querySelectorAll('.sizeButton');
     
     let isDrawing = false;
     let lastX = null;
     let lastY = null;
     let currentColor = "#000000";
     let currentSize = 5;
     let isFillMode = false;  // Kitöltési mód állapotának nyomon követése
     
     // Set white background for the canvas
     ctx.fillStyle = 'white';
     ctx.fillRect(0, 0, canvas.width, canvas.height);
     ctx.strokeStyle = currentColor;
     ctx.lineWidth = currentSize;
     
     // Kitöltés gomb eseménykezelője
     document.getElementById('fillModeButton').addEventListener('click', () => {
         isFillMode = true;  // Átvált kitöltési módra
         alert('Kitöltés módba léptél! Kattints egy területre a kitöltéshez.');
     });
     
     // Minden egyes ecset méret választásnál visszaállítunk rajzoló módra
     sizeButtons.forEach(button => {
         button.addEventListener('click', () => {
             currentSize = parseInt(button.getAttribute('data-size'));
             isFillMode = false;  // Visszaállítjuk rajzoló módba
         });
     });
     
     // Minden egyes színválasztásnál biztosítjuk, hogy a kitöltés is csak ezzel a színnel működjön
     colorButtons.forEach(button => {
         button.addEventListener('click', () => {
             currentColor = button.getAttribute('data-color');
             if (isFillMode) {
                 alert('Kitöltés csak az előre megadott színnel működik!');
             }
         });
     });
     
     // Módosítjuk a mousedown eseményt, hogy figyelje a kitöltés módot
     canvas.addEventListener('mousedown', (e) => {
         if (isFillMode) {
             const rect = canvas.getBoundingClientRect();
             const x = e.clientX - rect.left;
             const y = e.clientY - rect.top;
             
             // Kitöltés a kiválasztott színnel
             fill(x, y, currentColor);
         } else {
             // Ha nem kitöltési mód, akkor rajzolunk
             isDrawing = true;
             lastX = e.offsetX;
             lastY = e.offsetY;
             
             let radius = currentSize / 2;
             ctx.beginPath();
             ctx.arc(lastX, lastY, radius, 0, Math.PI * 2);
             ctx.fillStyle = currentColor;
             ctx.fill();
             ctx.closePath();
         }
     });
     
     // Frissítjük a fill() funkciót, hogy használja a currentColor-t
     function fill(x, y, fillColor) {
         const targetColor = ctx.getImageData(x, y, 1, 1).data;
     
         // Ha a kiválasztott szín megegyezik a cél színével, nem csinálunk semmit
         if (arraysEqual(targetColor, hexToRgb(fillColor))) {
             return;
         }
     
         const stack = [[x, y]];
         const width = canvas.width;
         const height = canvas.height;
     
         while (stack.length > 0) {
             const [currentX, currentY] = stack.pop();
     
             if (currentX < 0 || currentX >= width || currentY < 0 || currentY >= height) {
                 continue;
             }
     
             const currentColor = ctx.getImageData(currentX, currentY, 1, 1).data;
             if (!arraysEqual(currentColor, targetColor)) {
                 continue;
             }
     
             ctx.fillStyle = fillColor;
             ctx.fillRect(currentX, currentY, 1, 1);
     
             stack.push([currentX + 1, currentY]);
             stack.push([currentX - 1, currentY]);
             stack.push([currentX, currentY + 1]);
             stack.push([currentX, currentY - 1]);
         }
     }
     
     // Segédfüggvény a két RGB szín összehasonlításához
     function arraysEqual(a, b) {
         return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
     }
     
     // RGB hexadecimális szín átalakítása RGB objektummá
     function hexToRgb(hex) {
        const r = parseInt(hex.substring(1, 3), 16);
        const g = parseInt(hex.substring(3, 5), 16);
        const b = parseInt(hex.substring(5, 7), 16);
        return [r, g, b, 255];
     }
     
     // Vászon törlés
     function canvasClear() {
         ctx.fillStyle = 'white';
         ctx.fillRect(0, 0, canvas.width, canvas.height);
         ctx.strokeStyle = currentColor;
         ctx.lineWidth = currentSize;
     }
     
     // Mentés gomb eseménykezelője
     document.getElementById('saveButton').addEventListener('click', function() {
         // A canvas képe PNG formátumban
         const imageData = canvas.toDataURL('image/png');
     
         socket.send(JSON.stringify({
             type: 'save-drawing',
             imageFile: imageData
         }));
     });
    
</script>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
</body>
</html>
